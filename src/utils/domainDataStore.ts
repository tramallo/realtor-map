/** This file exposes stores that manages the data of the system
 * 
 * It has methods to perform CRUD operations & local copies of the info for quick access
 */
import { create } from "zustand";

import { CreateProperty, Property, UpdateProperty } from "./domainSchemas";
import { testProperties } from "./testData";


/** Describes the response returned by the operations on the store
 * 
 * Errors are not thrown, they are returned to be handled by consumer
 */
interface DataResponse<T> {
    data: T;
    error?: undefined;
}
interface ErrorResponse {
    data?: undefined;
    error: Error
}
type StoreResponse<T = undefined> = DataResponse<T> | ErrorResponse

/** Describes a store for properties
 */
interface PropertyStore {
    properties: Property[],
    createProperty: (newPropertyData: CreateProperty) => Promise<StoreResponse<Property['id']>>,
    removeProperty: (propertyId: Property['id']) => Promise<StoreResponse>,
    updateProperty: (propertyId: Property['id'], updatedProperty: UpdateProperty) => Promise<StoreResponse>
}

export const usePropertyStore = create<PropertyStore>((set) => ({
    properties: testProperties,
    createProperty: async (newPropertyData) => {
        // this data is generated by the db
        const newId: string = new Date().getTime().toString();
        const newProperty: Property = {
            id: newId,
            ...newPropertyData
        }

        set((prevState) => ({ properties: [...prevState.properties, newProperty] }))
        return { data: newProperty.id };
    },
    removeProperty: async (propertyId) => {
        set((prevState) => ({ properties: prevState.properties.filter((property) => property.id != propertyId) }))

        return { data: undefined }
    },
    updateProperty: async (propertyId, updatedProperty) => {
        set((prevState) => ({ properties: prevState.properties.map((property) => property.id == propertyId ? { ...property, ...updatedProperty } : property) }))
    
        return { data: undefined }
    },
}))
